/*
 * To change this template, choose Tools | Templates
 * and open the template in the editor.
 */

package json2java;

import java.io.*;
import java.util.*;
import edu.stanford.nlp.trees.*;
import edu.stanford.nlp.process.*;
//import edu.stanford.nlp.objectbank.TokenizerFactory;
import edu.stanford.nlp.parser.lexparser.LexicalizedParser;
import edu.stanford.nlp.ling.HasWord;
import org.htmlcleaner.XPatherException;

import json2java.TextPreprocessor;
import edu.stanford.nlp.process.Morphology;

/**
 *
 * @author Nikos Stasinopoulos <nstasinopoulos@gmail.com>
 * @version     Oct 27, 2010
 * @since       1.6
 */
public class NLPexample {

    LexicalizedParser lp = new LexicalizedParser("/home/nikos/NetBeansProjects/Thesis-Work/lib/stanford-parser-2010-07-09/englishPCFG.ser.gz");
    TreebankLanguagePack tlp = new PennTreebankLanguagePack();
    GrammaticalStructureFactory gsf = tlp.grammaticalStructureFactory();
    Morphology stemmer = new Morphology();
    TextPreprocessor tp = new TextPreprocessor();

    public Pair parseString(int sentenceMaxLength) throws IOException, XPatherException {


        //Strip html tags for body_html attribute
        String html = "<div><p>Trying to use PostgreSQL as DB backend for rail v2.3.4\n(gentoo).</p>\n<p>rake db:create:sessions uses rails string type for session_id\nfield. Unfortunately postgresql_adapter translates this type to\npostgres type: character varying with limit 255 (set explicitly in\nthe adapter code) which is too short for session_id generated by\nrails.</p>\n<p>I simply changed the limit value for the string type to 512 and\nit seems working, however I don't know how long this field should\nbe to handle every session_id generated by rails.</p>\n<p>The adapter was installed on my system together with\nactiverecord-2.3.4</p></div>";
        String text = new HTMLStripper().stripHTMLtags(html);
        text = tp.removeAnnoyingChars(text);

        try // device to handle potential errors
        {
            System.out.println("\n\n\nSTART\n\n\n"); // print START

            BufferedWriter outNoun = null;
            outNoun = new BufferedWriter(new FileWriter("example.txt", true));
//            outNoun.append(Integer.toString(ticket.getTicket().getNumber()));
//            outNoun.append(",");
//            outNoun.append(Integer.toString(ticket.getTicket().getVersionId()));
//            outNoun.append(",");


            lp.setOptionFlags(new String[]{"-maxLength", Integer.toString(sentenceMaxLength), "-retainTmpSubcategories"});//Maximum length allowed for a sentence
            //to get Stanford Parsed

            StringReader sr = new StringReader(text);
            List<List<? extends HasWord>> sentences = new DocumentPreprocessor(tlp.getTokenizerFactory()).getSentencesFromText(sr);

            ArrayList nouns = new ArrayList();
            ArrayList verbs = new ArrayList();
            if (sentences.size() == 0) {
                listPopulator(nouns, "denotesEmpty", "", outNoun);
            }
            for (List<? extends HasWord> sentence : sentences) {
                System.out.println("\nSentence:\t" + sentence);
                Tree parse = lp.apply(sentence);
                GrammaticalStructure gs = gsf.newGrammaticalStructure(parse);
                Collection tdl = gs.typedDependenciesCCprocessed(true);

                for (int i = 0; i < tdl.toArray().length; i++) {

                    TypedDependency x = (TypedDependency) tdl.toArray()[i]; //x holds current dependency

                    //Getting the relationships
                    //limits relations to desired  i.e. Subj/Obj
                     System.out.print(x.reln().getLongName() + "(");
                        System.out.print(x.gov().label().value()+"/"+x.gov().label().tag());
                        System.out.println(", "+ x.dep().label().value()+"/"+ x.dep().label().tag() +")");
                    if (TextPreprocessor.isDesiredRelation(x.reln().getLongName())) {

//                        System.out.print(x.reln().getLongName() + "(");
//                        System.out.print(x.gov().label().value()+"/"+x.gov().label().tag());
//                        System.out.println(", "+ x.dep().label().value()+"/"+ x.dep().label().tag() +")");

                        //populate nouns list
                        if (wordChecker(x.gov().label().tag(), "NN", nouns, stemmer.stem(x.gov().value()), 3, 20)) {
                            listPopulator(nouns, stemmer.stem(x.gov().value()), x.gov().label().tag(), outNoun);
                        }
                        if (wordChecker(x.dep().label().tag(), "NN", nouns, stemmer.stem(x.dep().value()), 3, 20)) {
                            listPopulator(nouns, stemmer.stem(x.dep().value()), x.dep().label().tag(), outNoun);
                        }

                        //populate verbs list
                        if (wordChecker(x.gov().label().tag(), "VB", nouns, stemmer.stem(x.gov().value()), 3, 20)) {
                            listPopulator(nouns, stemmer.stem(x.gov().value()), x.gov().label().tag(), outNoun);
                        }

                        if (wordChecker(x.dep().label().tag(), "VB", nouns, stemmer.stem(x.dep().value()), 3, 20)) {
                            listPopulator(nouns, stemmer.stem(x.dep().value()), x.dep().label().tag(), outNoun);
                        }

                    }
                }
            }
            System.out.println("\n" + nouns + "\n");

            outNoun.newLine();
            outNoun.flush();
            outNoun.close();
//

            return new Pair(nouns, verbs);

        } catch (Exception e) { // catch error if any
            System.err.println("ERROR in Parser: " + e.getMessage());
            e.printStackTrace();// print error message
//            ArrayList nouns = new ArrayList();
//            ArrayList verbs = new ArrayList();
//            nouns.add("empty");
//            nouns.add("empty");
            BufferedWriter outNoun = null;
            outNoun = new BufferedWriter(new FileWriter("example.txt", true));
//            outNoun.append("nnuull");
            outNoun.append("\n");//Add empty Line
            outNoun.flush();
            outNoun.close();
            return null;

        }
    }

     public boolean wordChecker(String tag, String typeAbbreviation, ArrayList members, String value, int minLength, int maxLength) {
        if (TextPreprocessor.isDesiredMember(tag, typeAbbreviation)
                && TextPreprocessor.isUnique(members, value)
                && TextPreprocessor.checkMinMaxLength(value, minLength, maxLength)) {
            return true;
        } else {

//            System.out.println(TextPreprocessor.isUnique(members, value)+"\t"+value +"\t"+tag);

            return false;
        }
    }

    public void listPopulator(ArrayList members, String word, String tag, BufferedWriter outNoun) throws IOException { //populate nouns list
//                    word = word.toLowerCase();
        if (!word.isEmpty() && !word.equals("")) {
            members.add(word);
            outNoun.append(word + " ");
        } else {
            members.add("denotesEmpty");
            outNoun.append("denotesEmpty" + " ");
        }
    }


}
